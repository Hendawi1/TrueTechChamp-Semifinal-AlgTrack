# Задача C. Отражения сигнала (True Tech Champ)

Этот репозиторий содержит подробный разбор задачи **"Отражения сигнала"**, предназначенной для тренировки навыков анализа и симметричных отражений лучей. Задача расположена в отдельной папке и содержит два файла:

1. **задача.pdf** — полная формулировка задачи с примерами и графическим изображением модели.
2. **Решение.py** — готовый код решения на C++ с подробными комментариями.

Раит-ап разбит на три раздела, каждый из которых содержит детальное объяснение:

1. **Подробное объяснение вопроса**
2. **Теоретическое объяснение решения**
3. **Подробный разбор кода решения**

---

## 1. Подробное объяснение вопроса

Задача моделирует распространение сигнала 5G в замкнутом тоннеле метро. Основные условия и компоненты задачи:

* **Модель тоннеля:** единичная окружность с центром в точке (0,1) представляет поперечное сечение тоннеля.
* **Передатчик и приёмник:** оба находятся в начале координат (0,0).
* **Начальный сигнал:** из передатчика исходит луч под углом `p/q` градусов относительно оси X.
* **Отражение:** при столкновении с окружностью сигнал отражается так, что угол между лучом и прямой к центру окружности сохраняется (закон отражения относительно радиуса).
* **Цель:** определить, сколько отражений произойдёт до того, как сигнал вернется в приёмник.

**Ключевые детали и ограничения:**

* `n` — количество пар `(p,q)` (1 ≤ n ≤ 10^5).
* Каждая пара целых чисел `(pi, qi)` задаёт угол луча в градусах: `pi/qi`.
* Ограничения на числа: 1 ≤ pi, qi ≤ 10^16, gcd(pi, qi) = 1.
* Выход: количество отражений до попадания в приёмник для каждой пары.

**Пример входных данных:**

```
6
1 2
30 1
8 9
45 2
3 14
15 1
```

**Соответствующий вывод:**

```
359
5
404
7
839
11
```

Каждая пара чисел соответствует уникальной траектории луча и уникальному числу отражений.

---

## 2. Теоретическое объяснение решения

Для решения задачи необходимо учитывать геометрическую симметрию отражений:

1. **Основные наблюдения:**

   * Лучи отражаются симметрично относительно радиуса, соединяющего точку отражения с центром окружности.
   * После определённого числа отражений луч возвращается к начальной точке, при этом количество отражений всегда целое.

2. **Сокращение задачи к вычислению числа отражений:**

   * Пусть угол `α = p/q` градусов относительно оси X.
   * Количество отражений можно вычислить по формуле:
     [
     ext{отражения} = \frac{180 \cdot q}{\gcd(p, 180)} - 1
     ]
   * `gcd(p,180)` учитывает симметрию угла относительно полного круга (180°).

3. **Пошаговая логика:**

   * Введём понятие «базового угла»: угол между исходным лучом и осью X.
   * Отражение изменяет направление луча, но сохраняет относительный угол с радиусом.
   * Когда луч возвращается в начало координат, число совершённых отражений кратно `180/gcd(p,180) * q`.
   * Вычитание единицы корректирует итоговое число, поскольку первый луч ещё не отразился.

4. **Почему эта формула корректна:**

   * Симметрия окружности и закон отражения гарантируют, что луч всегда вернётся в начало после целого числа отражений.
   * Использование gcd позволяет правильно определить кратность угла и избежать дробных отражений.

5. **Дополнительно:**

   * При больших значениях `p` и `q` (до 10^16) важно использовать целочисленные вычисления, чтобы избежать ошибок округления.
   * Решение полностью детерминировано и не требует моделирования каждого отражения.

---

## 3. Подробный разбор кода решения

```cpp
#include <bits/stdc++.h>
using namespace std;
using int64 = long long;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n;
    if (!(cin >> n)) return 0; // чтение количества пар
    while (n--) {
        int64 p, q;
        cin >> p >> q; // чтение пары чисел p и q
        int64 g = std::gcd(p, (int64)180); // наибольший общий делитель p и 180
        cout << (180LL * q / g - 1) << '\n'; // вычисление числа отражений
    }
}
```

**Подробное объяснение кода:**

1. `ios::sync_with_stdio(false); cin.tie(nullptr);` — ускоряет ввод/вывод, отключая синхронизацию с C I/O.
2. Чтение числа `n` — количества тестов.
3. `while (n--)` — цикл по каждой паре `(p,q)`.
4. `int64 g = std::gcd(p, 180);` — нахождение gcd для корректного расчёта отражений.
5. `180LL * q / g - 1` — применение формулы для вычисления количества отражений.
6. `cout << ... << '\n';` — вывод результата для каждой пары.

**Преимущества решения:**

* Эффективность: подходит для n до 10^5 и больших p, q.
* Простота: используется стандартная функция gcd и базовые операции.
* Надёжность: точно вычисляет целое число отражений без моделирования траектории.

---

## Пример работы программы

**Входные данные:**

```
6
1 2
30 1
8 9
45 2
3 14
15 1
```

**Выходные данные:**

```
359
5
404
7
839
11
```

Каждый результат соответствует количеству отражений для конкретного угла `p/q` градусов.
