# Самокаты и пробки

Этот репозиторий содержит **подробный профессиональный разбор задачи “Самокаты и пробки”**, предназначенный для глубокого изучения всех аспектов решения. Задача расположена в отдельной папке и содержит два основных файла:

1. **задача.pdf** — полная формулировка задачи с примерами, графическими схемами и пояснениями к формату входных и выходных данных.
2. **Решение.py** — готовый код решения с оптимальной сложностью и комментариями по каждой логической части.

Раит-ап разбит на три основных раздела:

1. **Подробное объяснение вопроса**
2. **Теоретическое объяснение решения**
3. **Подробный разбор кода решения и алгоритмических приёмов**

---

## 1. Подробное объяснение вопроса

В задаче моделируется город в виде полного графа с `n` вершинами, где каждая вершина — это площадь города, а каждое ребро — улица с двусторонним движением. Каждая вершина `i` имеет стоимость `2^i`.

В час пик движение может быть затруднено на некотором подмножестве улиц. Для обеспечения доступности транспорта система управления МТС Юрент добавляет самокаты на вершины графа так, чтобы:

* На каждой загруженной улице хотя бы одна из вершин имела самокат.
* Сумма стоимостей выбранных вершин была минимальной.

**Задача**: определить, сколько существует возможных наборов множеств улиц с затрудненным движением, для которых минимальная сумма стоимостей выбранных вершин равна заданному числу `k`. Поскольку число наборов может быть очень большим, результат необходимо вывести по модулю `10^9 + 7`.

### Входные данные

* Первая строка содержит целое число `t` — количество тестовых примеров (1 ≤ t ≤ 2147).
* Каждая из последующих `t` строк содержит два числа: `n` (1 ≤ n ≤ 100 000) — количество вершин, и `k` — целое число в **двоичной системе**, 0 ≤ k < 2^n.
* Гарантируется, что сумма всех n по тестам ≤ 250 000.

### Выходные данные

* Для каждого тестового примера вывести одно целое число — количество наборов множеств улиц с минимальной суммой, равной `k`.

### Пример

| Входные данные | Выходные данные |
| -------------- | --------------- |
| 3              | 3               |
| 3 1            | 84              |
| 5 101          | 78707805        |
| 11 101010101   |                 |

**Дополнительно:**

* Для больших n важно учитывать оптимизацию по памяти и времени.
* Подсчет комбинаций рёбер и вершин должен выполняться через модульную арифметику.

---

## 2. Теоретическое объяснение решения

### Шаг 1: Преобразование числа `k` в битовую маску

Каждое число `k` в двоичной системе показывает, какие вершины должны быть выбраны для получения минимальной суммы. Например, если `k = 101` (биты с нуля справа налево), это значит, что для минимальной суммы должны быть выбраны вершины с номерами 0 и 2.

### Шаг 2: Определение множества свободных вершин (U)

* Вершины, которые не входят в число `k` (бит равен 0), могут быть добавлены в набор без увеличения минимальной суммы.
* Формируется массив `isU`, где `isU[i] = 1`, если вершина `i` свободна.

### Шаг 3: Подсчет влияния фиксированных вершин

* Для каждой вершины, которая должна быть включена (бит равен 1), определяются все комбинации подключений к вершинам из множества U.
* Используется формула: количество способов = 2^a_i - 1, где a_i — количество свободных вершин после i.

### Шаг 4: Подсчет свободных рёбер

* Рёбра, соединяющие только вершины из множества U, не влияют на минимальную сумму и могут присутствовать или отсутствовать.
* Количество способов включения/исключения свободных рёбер вычисляется как 2^free_edges.

### Шаг 5: Вычисление результата

* Общий результат = произведение способов для фиксированных вершин * количество вариантов свободных рёбер (по модулю 10^9 + 7).
* Для больших n используется быстрый модульный экспоненциальный алгоритм.

---

## 3. Подробный разбор кода решения

```cpp
#include <bits/stdc++.h>
using namespace std;
using int64 = long long;
const int MOD = 1000000007;

// Функция для быстрого возведения числа в степень по модулю MOD
int64 modpow(int64 a, long long e) {
    int64 r = 1 % MOD;
    a %= MOD;
    while (e > 0) {
        if (e & 1) r = (r * a) % MOD;
        a = (a * a) % MOD;
        e >>= 1;
    }
    return r;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t;
    if (!(cin >> t)) return 0;

    while (t--) {
        int n;
        string ks;
        cin >> n >> ks;

        // Дополняем двоичную строку нулями слева до длины n
        if ((int)ks.size() < n) ks = string(n - ks.size(), '0') + ks;

        vector<int> bit(n, 0);
        for (int i = 0; i < n; ++i) if (ks[i] == '1') bit[n - 1 - i] = 1;

        // Если старший бит 1, минимальная сумма невозможна
        if (bit[n-1] == 1) { cout << 0 << '\n'; continue; }

        // Определяем свободные вершины
        vector<int> isU(n, 0);
        for (int i = 0; i < n; ++i) isU[i] = (bit[i] == 0) ? 1 : 0;

        // Суффиксная сумма свободных вершин
        vector<int> suff(n+1, 0);
        for (int i = n-1; i >= 0; --i) suff[i] = suff[i+1] + isU[i];

        long long m = suff[0];
        long long total_edges = (long long)n * (n - 1) / 2;
        long long internal_U = m * (m - 1) / 2;
        int64 prod = 1;
        long long sum_a = 0;

        // Подсчет способов для каждой фиксированной вершины
        for (int i = 0; i < n; ++i) {
            if (!isU[i]) {
                long long a_i = suff[i+1];
                if (a_i == 0) { prod = 0; break; }
                sum_a += a_i;
                int64 term = (modpow(2, a_i) - 1) % MOD;
                if (term < 0) term += MOD;
                prod = (prod * term) % MOD;
            }
        }

        if (prod == 0) { cout << 0 << '\n'; continue; }

        // Подсчет свободных рёбер
        long long free_edges = total_edges - internal_U - sum_a;
        if (free_edges < 0) { cout << 0 << '\n'; continue; }

        int64 ways_free = modpow(2, free_edges);
        int64 ans = (prod * ways_free) % MOD;
        cout << ans << '\n';
    }
    return 0;
}
```

### Подробное объяснение кода:

1. **modpow** — быстрое возведение числа в степень по модулю, используя бинарное разложение степени.
2. **Входные данные** — читаем количество тестов `t`, затем `n` и `k` в двоичной форме.
3. **Проверка старшего бита** — если вершина с наибольшей стоимостью должна быть включена, решения нет.
4. **isU** — массив свободных вершин, которые могут присутствовать в любом наборе.
5. **suff** — массив суффиксных сумм для быстрого подсчета свободных вершин после каждой позиции.
6. **Основной цикл** — подсчет количества способов выбора фиксированных вершин для минимальной суммы.
7. **free_edges** — количество рёбер, не влияющих на минимальную сумму; для них используем 2^free_edges.
8. **ans** — итоговый результат, умножение комбинаций фиксированных вершин на способы свободных рёбер.

### Особенности решения:

* Высокая эффективность и оптимизация по времени и памяти.
* Полностью учитываются ограничения задачи по n и сумме n.
* Применяются продвинутые методы комбинаторики и модульной арифметики для больших чисел.
* Код легко адаптируется для других языков программирования (Python, Java, C#) при сохранении логики.
