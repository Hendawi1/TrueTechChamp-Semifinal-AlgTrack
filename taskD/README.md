# Просто квадрат (МТС акция)

Этот репозиторий содержит подробный разбор задачи **“Просто квадрат”**. Задача расположена в отдельной папке и содержит два файла:

1. **задача.pdf** — полная формулировка задачи.
2. **Решение.py** — готовый код решения.

Раит-ап разбит на три раздела:

1. **Подробное объяснение вопроса**
2. **Теоретическое объяснение решения**
3. **Подробный разбор кода решения**

---

## 1. Подробное объяснение вопроса

В задаче рассматривается акция МТС для специальных телефонных номеров. Основная идея задачи заключается в том, что номер должен удовлетворять двум условиям одновременно:

* **Одно представление номера — простое число**. Это может быть либо международный формат (+7 XXX XXXXXXX), либо локальный (8 XXX XXXXXXX).
* **Другое представление номера — точный квадрат целого числа**.

Таким образом, номер должен иметь уникальную комбинацию цифр, при которой один вариант является простым числом, а другой — квадратом.

**Структура номера в России:**

* Первая цифра: код страны (7 для международного, 8 для локального).
* Следующие три цифры: префикс, задающий регион или оператор.
* Последние семь цифр: индивидуальный номер абонента.

**Входные данные:**

* `t` — количество тестовых случаев (1 ≤ t ≤ 1000).
* Далее `t` строк с трёхзначным префиксом.

**Выходные данные:**

* Для каждого теста вывести: количество найденных номеров и сами номера в **10-значном виде**, без ведущей цифры кода страны.
* Номера должны быть отсортированы по возрастанию.

Пример входа и выхода:

| Вход            | Выход                                                         |
| --------------- | ------------------------------------------------------------- |
| 2<br>916<br>042 | 2 9164012321 9169639641<br>3 0420706161 0422829129 0426013641 |

**Комментарии к примеру:**

* Для префикса `916` найдены два номера, подходящие под условия акции.
* Для префикса `042` найдены три номера.
* Если подходящих номеров нет, выводится только число `0`.

---

## 2. Теоретическое объяснение решения

### Шаг 1: Формирование диапазона номеров

* Для каждого теста берём трёхзначный префикс `P`.
* Рассматриваем все 7-значные окончания номера `S` от `0000000` до `9999999`.
* Формируем полные номера в двух форматах: `7PSSSSSSS` и `8PSSSSSSS`.

### Шаг 2: Проверка на квадрат числа

* Для каждого номера проверяем, может ли он быть точным квадратом целого числа.
* Используем целочисленные функции `isqrt_floor` и `isqrt_ceil`, чтобы найти возможный диапазон `k` таких, что `k^2` попадает в нужный диапазон номера.

### Шаг 3: Проверка на простое число

* Для числа из другого формата проверяем простоту с помощью детерминированного алгоритма **Miller-Rabin** для 64-битных чисел.
* Это позволяет быстро и корректно проверять большие числа без ошибок переполнения.

### Шаг 4: Фильтрация и добавление в результат

* Если один вариант номера — квадрат, а другой — простое число, добавляем 10-значную версию номера без кода страны в результат.
* Используем `set`, чтобы избежать дублирования номеров.
* После обработки всех вариантов сортируем результаты по возрастанию для вывода.

### Шаг 5: Сложность решения

* Перебор всех 7-значных чисел напрямую неэффективен, поэтому используется математический метод поиска квадратного корня, ограничивающий диапазон поиска.
* Проверка простоты с помощью Miller-Rabin обеспечивает детерминированный результат за логарифмическое время по величине числа.

---

## 3. Подробный разбор кода решения

```cpp
#include <bits/stdc++.h>
using namespace std;
using u64 = unsigned long long;
using u128 = __uint128_t;

// Безопасное умножение по модулю для больших чисел
u64 mul_mod(u64 a, u64 b, u64 mod) { return (u128)a * b % mod; }

// Возведение в степень по модулю
u64 pow_mod(u64 a, u64 d, u64 mod) {
    u64 res = 1;
    while (d) {
        if (d & 1) res = mul_mod(res, a, mod);
        a = mul_mod(a, a, mod);
        d >>= 1;
    }
    return res;
}

// Проверка простого числа детерминированным Miller-Rabin
bool miller_rabin(u64 n) { ... }

// Целочисленные квадратные корни
u64 isqrt_floor(u64 x) { ... }
u64 isqrt_ceil(u64 x) { ... }

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int t;
    cin >> t;
    const u64 TEN10 = 10000000000ULL;
    const u64 TEN7 = 10000000ULL;
    
    for (int ti = 0; ti < t; ++ti) {
        string pref;
        cin >> pref;
        u64 P = stoull(pref);
        set<u64> answers;
        
        // Проверяем оба формата: 7 — квадрат, 8 — простое и наоборот
        for (int d = 7; d <= 8; ++d) {
            u64 base = d * TEN10 + P * TEN7;
            u64 low = base;
            u64 high = base + TEN7 - 1;
            u64 k_lo = isqrt_ceil(low);
            u64 k_hi = isqrt_floor(high);
            
            for (u64 k = k_lo; k <= k_hi; ++k) {
                u64 square = k * k;
                u64 S = square - d * TEN10;
                int other_d = (d == 7 ? 8 : 7);
                u64 otherN = other_d * TEN10 + S;
                
                if (S >= P * TEN7 && S <= P * TEN7 + TEN7 - 1 && miller_rabin(otherN))
                    answers.insert(S);
            }
        }
        
        vector<u64> out(answers.begin(), answers.end());
        sort(out.begin(), out.end());
        
        cout << out.size();
        for (u64 s : out) {
            string ss = to_string(s);
            if (ss.size() < 10) ss = string(10 - ss.size(), '0') + ss;
            cout << ' ' << ss;
        }
        cout << '\n';
    }
    
    return 0;
}
```

### Пояснение кода

* **mul_mod и pow_mod**: используются для безопасной работы с большими числами и возведения в степень по модулю.
* **miller_rabin**: проверяет число на простоту для 64-битных чисел с гарантией корректности.
* **isqrt_floor и isqrt_ceil**: вычисляют целочисленные квадратные корни с учетом округления вниз и вверх.
* **Основной цикл**: перебирает оба варианта номера, проверяет квадрат и простоту, сохраняет подходящие номера.
* **set**: обеспечивает уникальность номеров.
* **Сортировка и вывод**: формирует финальный результат в нужном формате.

---

## Пример работы

**Входные данные:**

```
2
916
042
```

**Выходные данные:**

```
2 9164012321 9169639641
3 0420706161 0422829129 0426013641
```

---

> **Замечания:**
>
> * Алгоритм эффективно обрабатывает до 1000 тестов с большим диапазоном номеров.
> * Использование 128-битной арифметики предотвращает переполнение при работе с большими числами.
> * Применение Miller-Rabin обеспечивает точность при проверке простых чисел в диапазоне 10^10.
