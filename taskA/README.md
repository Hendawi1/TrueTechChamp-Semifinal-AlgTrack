# Стабильна ли строка (True Tech Champ)

Этот репозиторий содержит подробный разбор задачи **“Стабильна ли строка”**, взятой из трека 1 полуфинала соревнования True Tech Champ. Задача расположена в отдельной папке и содержит два файла:

1. **задача.pdf** — полная формулировка задачи, включая примеры, ограничения и пояснения.
2. **Решение.py** — готовый код решения на C++ (или Python, при необходимости), который полностью соответствует условию задачи.

Раит-ап структурирован в три раздела, каждый из которых подробно объясняет различные аспекты задачи и решения:

1. **Подробное объяснение вопроса**
2. **Теоретическое объяснение решения**
3. **Подробный разбор кода решения**

---

## 1. Подробное объяснение вопроса

В задаче дана строка, составленная из букв **M**, **T** и **C**. Строка может быть преобразована в число путем замены каждой буквы на цифру от 0 до 9 с соблюдением следующих правил:

* Одинаковые буквы должны заменяться на одинаковые цифры.
* Разные буквы должны заменяться на разные цифры.
* Строка не должна начинаться с нуля после замены (т.е. запрещены ведущие нули).

Строка считается **стабильной**, если **для всех допустимых замен букв цифрами цифровой корень числа всегда одинаковый**.

Цифровой корень числа определяется как последовательное суммирование цифр числа до тех пор, пока не останется однозначное число. Например, для числа 9876:

```
9 + 8 + 7 + 6 = 30
3 + 0 = 3
Цифровой корень = 3
```

**Входные данные:**

* Первое число `t` — количество тестовых примеров (1 ≤ t ≤ 100).
* Далее `t` строк, каждая состоит из букв M, T, C, длиной до 10^4.

**Выходные данные:**

* Для каждого тестового примера выводится `1`, если строка стабильна, и `0`, если нестабильна.

**Пример:**

```
Входные данные:
2
MTMTTMMTTTMMTMMTTM
MTC

Выходные данные:
1
0
```

В первом случае строка стабильна, во втором — нет.

**Важно:**

* Строка может содержать все три буквы, или только одну/две.
* Учитываются все возможные допустимые комбинации цифр.

## 2. Теоретическое объяснение решения

### 2.1 Понимание цифрового корня

* Цифровой корень числа не зависит от точного расположения цифр, а зависит только от суммы цифр числа по модулю 9.
* Свойство цифрового корня: `digital_root(x) = 1 + (x - 1) % 9` для x > 0.
* Это означает, что **все комбинации, которые дают одинаковую сумму по модулю 9, дадут один и тот же цифровой корень**.

### 2.2 Анализ стабильности строки

* Обозначим количество каждой буквы в строке:

  * `count(M)` — количество букв M
  * `count(T)` — количество букв T
  * `count(C)` — количество букв C
* Если хотя бы один из счетчиков не кратен 9, то можно подобрать такие цифры для букв, чтобы сумма цифр была разной по модулю 9, что приведет к разным цифровым корням.
* Таким образом, **необходимое условие стабильности**: каждая встречающаяся буква должна встречаться число раз, кратное 9.

### 2.3 Пример анализа

Строка `MTC`:

* count(M) = 1, count(T) = 1, count(C) = 1
* Каждое число не кратно 9 → строка нестабильна

Строка `MMMMMMMMM` (9 M):

* count(M) = 9 → кратно 9, все остальные = 0 → стабильна

### 2.4 Алгоритм проверки

1. Считаем количество букв M, T, C.
2. Проверяем, кратно ли 9 количество каждой буквы (если она присутствует).
3. Если все условия выполняются → строка стабильна, иначе нестабильна.

**Сложность алгоритма:**

* O(n) на каждый тест, где n — длина строки (эффективно для n ≤ 10^4).

## 3. Подробный разбор кода решения

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t;
    if (!(cin >> t)) return 0;  // читаем количество тестов

    string s;
    while (t--) {
        cin >> s;  // читаем строку
        array<int,3> cnt = {0,0,0};  // счетчики для M, T, C

        // Подсчет букв
        for (char ch : s) {
            if (ch == 'M') ++cnt[0];
            else if (ch == 'T') ++cnt[1];
            else if (ch == 'C') ++cnt[2];
        }

        // Проверка стабильности
        bool stable = true;
        for (int i = 0; i < 3; ++i) {
            if (cnt[i] > 0 && (cnt[i] % 9 != 0)) {
                stable = false;
                break;
            }
        }

        // Вывод результата
        cout << (stable ? 1 : 0) << '\n';
    }
    return 0;
}
```

**Пошаговое объяснение кода:**

1. `ios::sync_with_stdio(false); cin.tie(nullptr);` — ускоряет ввод и вывод, отключая синхронизацию с C-потоками.
2. `cin >> t` — читаем количество тестовых примеров.
3. Цикл `while (t--)` — обрабатываем каждый тест.
4. `array<int,3> cnt` — массив для подсчета количества каждой буквы.
5. Цикл `for (char ch : s)` — подсчитываем буквы M, T, C.
6. Проверка `cnt[i] % 9 != 0` — если буква встречается не кратное 9 раз, строка нестабильна.
7. `cout << (stable ? 1 : 0) << '\n';` — вывод результата для каждого теста.

**Особенности решения:**

* Эффективность для больших строк (до 10^4 символов).
* Минимальное использование памяти и операций.
* Использует свойства цифрового корня для оптимальной проверки стабильности.

---

## Пример работы

**Входные данные:**

```
2
MTMTTMMTTTMMTMMTTM
MTC
```

**Выходные данные:**

```
1
0
```

> **Примечание:**
> Данный раит-ап подходит для публикации на GitHub, содержит полное объяснение задачи, теоретическую часть и детальный разбор кода решения. Все шаги тщательно объяснены для максимального понимания.
