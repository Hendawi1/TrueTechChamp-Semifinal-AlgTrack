# Детализация и вирус (Задача B)

Этот репозиторий содержит подробный и расширенный разбор задачи **“Детализация и вирус”**. Задача расположена в отдельной папке и содержит два файла:

1. **задача.pdf** — полная формулировка задачи, включая все входные и выходные данные, ограничения и примеры.
2. **Решение.py** — готовый код решения, с подробными комментариями и объяснениями каждого шага.

Райт-ап разделен на три основных раздела, каждый из которых предоставляет максимально подробное объяснение:

1. **Подробное объяснение вопроса**
2. **Теоретическое объяснение решения**
3. **Подробный разбор кода решения**

Также включены дополнительные советы по оптимизации и проверке корректности данных.

---

## 1. Подробное объяснение вопроса

В задаче рассматривается массив телефонной детализации, который мог быть перемешан вирусом. Детализация состоит из чисел `ci`:

* `ci > 0` — время установки соединения.
* `ci < 0` — время разрыва соединения `-ci`.

Основные правила корректной детализации:

1. В каждый момент времени может быть **только одно соединение**.
2. Каждое соединение должно иметь **сначала установку, затем разрыв**, и они должны идти **в паре**.
3. Все соединения должны происходить **внутри периода детализации** (нет неучтенных начальных или конечных соединений).
4. Пользователь предполагает, что вирус только **переставляет элементы массива**, не добавляет новые или не удаляет существующие записи.

**Примеры корректных последовательностей:**

* `[123, -456]` → соединение длится 333 секунды (456 − 123)
* `[111, -111]` → соединение длится 0 секунд
* `[-234, 234]` → новое соединение начинается сразу после сброса предыдущего

**Примеры некорректных последовательностей:**

* `[4, -1, 9]` — разрыв без соответствующего начала
* `[8, 8, -8, -8]` — несколько разрывов или начала в один момент, что невозможно

**Задача:**

* Проверить, возможно ли восстановить корректную последовательность
* Если возможно, вычислить суммарное время всех соединений
* Если данные повреждены иначе, кроме перестановки, вывести `-1`

---

## 2. Теоретическое объяснение решения

### Шаг 1: Проверка базовых условий

1. **Баланс положительных и отрицательных чисел:**
   Для корректной детализации количество установок должно совпадать с количеством разрывов.
2. **Отсутствие нулей:**
   Значение `0` не допускается и указывает на некорректность данных.

### Шаг 2: Сортировка

1. Для восстановления корректной последовательности необходимо отсортировать массив по **абсолютной величине числа**.
2. При совпадении абсолютных значений **положительное число ставим перед отрицательным**, чтобы соблюсти порядок установки → разрыв.

### Шаг 3: Использование стека

1. Стек нужен для отслеживания текущего открытого соединения.
2. Алгоритм:

   * Если число положительное — помещаем его в стек (открываем соединение).
   * Если число отрицательное — извлекаем верх стека:

     * Если стек пуст — некорректная последовательность
     * Если начало соединения больше конца — некорректная последовательность
     * Иначе вычисляем длительность и добавляем к сумме
3. После прохода по массиву стек должен быть пуст — если нет, значит есть незавершенные соединения.

### Шаг 4: Вычисление суммарного времени

* Для каждого корректного соединения вычисляем разницу между временем разрыва и установкой соединения
* Суммируем все значения для получения итогового времени соединений

### Шаг 5: Обработка ошибок

* Несбалансированные числа (разные количества + и -)
* Появление нулей
* Некорректный порядок по модулю

---

## 3. Подробный разбор кода решения

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
using namespace std;

int main() {
    int t;
    cin >> t; // Чтение количества тестов
    while (t--) {
        int n;
        cin >> n; // Чтение количества записей
        vector<int> a(n);
        bool hasZero = false;
        int positiveCount = 0;
        int negativeCount = 0;

        // Чтение массива и проверка базовых условий
        for (int i = 0; i < n; i++) {
            cin >> a[i];
            if (a[i] == 0) hasZero = true;
            else if (a[i] > 0) positiveCount++;
            else negativeCount++;
        }

        // Если данные некорректны по базовым условиям, выводим -1
        if (hasZero || positiveCount != negativeCount) {
            cout << -1 << endl;
            continue;
        }

        // Сортировка по абсолютной величине с приоритетом положительных чисел
        sort(a.begin(), a.end(), [](int x, int y) {
            if (abs(x) == abs(y)) return x > y; // положительное раньше отрицательного
            return abs(x) < abs(y);
        });

        stack<int> st;
        long long ans = 0;
        bool valid = true;

        // Проход по массиву для подсчета суммарного времени
        for (int i = 0; i < n; i++) {
            if (a[i] > 0) st.push(a[i]); // открытие соединения
            else {
                if (st.empty()) { valid = false; break; } // некорректная последовательность
                int s = st.top(); st.pop(); // извлечение времени установки
                int e = -a[i]; // время разрыва
                if (s > e) { valid = false; break; } // проверка корректности
                ans += e - s; // суммирование времени соединения
            }
        }

        // Если стек не пуст — соединение не завершено
        if (!st.empty()) valid = false;

        // Вывод результата
        cout << (valid ? ans : -1) << endl;
    }
    return 0;
}
```

**Подробное объяснение каждой строки кода:**

1. `cin >> t` — считываем количество тестов.
2. Цикл `while (t--)` — обрабатываем каждый тест отдельно.
3. `vector<int> a(n)` — массив деталей звонков.
4. Переменные `hasZero`, `positiveCount`, `negativeCount` — проверка базовых условий.
5. Сортировка с лямбда-функцией — гарантирует правильный порядок начала и конца соединений.
6. `stack<int> st` — хранение открытых соединений.
7. В цикле проверяем и суммируем время соединений, если последовательность корректна.
8. Проверка `!st.empty()` — все соединения должны быть завершены.
9. Вывод суммы времени соединений или `-1`, если данные некорректны.

---

## 4. Примеры работы

**Входные данные:**

```
1
6
4 -6 8 -9 -16
```

**Выходные данные:**

```
11
```

**Входные данные с ошибкой:**

```
1
6
8 8 8 -8 -8 -8
```

**Выходные данные:**

```
-1
```

---

## 5. Дополнительные советы

* Для больших массивов используйте эффективные структуры данных, например `std::stack` для управления соединениями.
* Сортировка гарантирует корректное сопоставление пар установка → разрыв.
* Проверка баланса + и - чисел предотвращает ошибки на раннем этапе.
* В Python можно реализовать аналогичный подход с `list` и методами `append` / `pop`.
